{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"],"fields":{"title":{"boost":1000.0},"text":{"boost":1.0},"tags":{"boost":1000000.0}}},"docs":[{"location":"","title":"FastAPI Api Key","text":"<p><code>fastapi-api-key</code> provides a backend-agnostic library that provides a production-ready, secure API key system, with optional FastAPI and Typer connectors.</p>"},{"location":"#links","title":"Links","text":"<ul> <li>Documentation: https://athroniaeth.github.io/fastapi-api-key/</li> <li>PyPI package: https://pypi.org/project/fastapi-api-key/</li> </ul>"},{"location":"#features","title":"Features","text":"<ul> <li>Security-first: secrets are hashed with a salt and a pepper, and never logged or returned after creation</li> <li>Prod-ready: services and repositories are async, and battle-tested</li> <li>Agnostic hasher: choose between Argon2 (default) or Bcrypt hashing strategies (with caching support)</li> <li>Agnostic backend: abstract repository pattern, currently with SQLAlchemy implementation</li> <li>Connectors: FastAPI router and Typer CLI for API key management</li> <li>Envvar support: easily configure peppers and other secrets via environment variables</li> <li>Scopes support: assign scopes to API keys for fine-grained access control</li> </ul>"},{"location":"#standards-compliance","title":"Standards compliance","text":"<p>This library try to follow best practices and relevant RFCs for API key management and authentication:</p> <ul> <li>RFC 9110/7235: Router raise 401 for missing/invalid keys, 403 for   valid but inactive/expired keys</li> <li>RFC 6750: Supports <code>Authorization: Bearer &lt;api_key&gt;</code> header for   key transmission (also supports deprecated <code>X-API-Key</code> header and <code>api_key</code> query param)</li> </ul>"},{"location":"#how-api-keys-work","title":"How API Keys Work","text":""},{"location":"#api-key-format","title":"API Key Format","text":"<p>This is a classic API key if you don't modify the service behavior:</p> <p>Structure:</p> <p><code>{global_prefix}</code>-<code>{separator}</code>-<code>{key_id}</code>-<code>{separator}</code>-<code>{key_secret}</code></p> <p>Example:</p> <p><code>ak-7a74caa323a5410d-mAfP3l6yAxqFz0FV2LOhu2tPCqL66lQnj3Ubd08w9RyE4rV4skUcpiUVIfsKEbzw</code></p> <ul> <li>\"-\" separators so that systems can easily split</li> <li>Prefix <code>ak</code> (for \"Api Key\"), to identify the key type (useful to indicate that it is an API key).</li> <li>16 first characters are the identifier (UUIDv4 without dashes)</li> <li>64 last characters are the secret (random alphanumeric string)</li> </ul> <p>When verifying an API key, the service extracts the identifier, retrieves the corresponding record from the repository, and compares the hashed secret. If found, it hashes the provided secret (with the same salt and pepper) and compares it to the stored hash. If they match, the key is valid.</p>"},{"location":"#schema-validation","title":"Schema validation","text":"<p>Here is a diagram showing what happens after you initialize your API key service with a global prefix and delimiter when you provide an API key to the <code>.verify_key()</code> method.</p> <p></p>"},{"location":"#additional-notes","title":"Additional notes","text":"<ul> <li>Python 3.9+ is required.</li> <li>The library issues warnings if you keep the default pepper; always configure a secret value outside source control.</li> <li>Never log peppers or plaintext API keys, change the pepper of prod will prevent you from reading API keys</li> </ul>"},{"location":"#development-helpers","title":"Development helpers","text":"<p>Run the curated lint suite with <code>make lint</code>; it chains Ruff format/check, Ty, Pyrefly, and Bandit via <code>uv run</code> so CI and local runs match. Install <code>make</code> with <code>sudo apt install make</code> on Debian/Ubuntu or <code>choco install make</code> (or the binary from Git for Windows) before executing commands from the repository root.</p>"},{"location":"#what-to-read-next","title":"What to read next","text":"<ol> <li>Head to the Quickstart to wire the service in a REPL or script.</li> <li>Browse the Usage section to see example applications that ship with the project.</li> </ol>"},{"location":"quickstart/","title":"Quickstart","text":"<p>This quickstart guide helps you set up the package and create your first API key. It assumes you have Python 3.9+ installed.</p>"},{"location":"quickstart/#1-install-dependencies","title":"1. Install dependencies","text":""},{"location":"quickstart/#basic-installation","title":"Basic installation","text":"<p>This project is published on PyPI. Use a tool like uv to manage dependencies.</p> <pre><code>uv add fastapi-api-key\n</code></pre> <p>or using pip: <pre><code>pip install fastapi-api-key\n</code></pre></p>"},{"location":"quickstart/#2-create-api-key","title":"2. Create api key","text":"<p>Create a script and run the following code. This mirrors <code>examples/example_inmemory.py</code>.</p> <pre><code>import asyncio\nimport os\n\nfrom fastapi_api_key import ApiKeyService\nfrom fastapi_api_key.hasher.argon2 import Argon2ApiKeyHasher\nfrom fastapi_api_key.repositories.in_memory import InMemoryApiKeyRepository\n\n# Set env var to override default pepper\n# Using a strong, unique pepper is crucial for security\n# Default pepper is insecure and should not be used in production\npepper = os.getenv(\"SECRET_PEPPER\")\nhasher = Argon2ApiKeyHasher(pepper=pepper)\n\n# default hasher is Argon2 with a default pepper (to be changed in prod)\nrepo = InMemoryApiKeyRepository()\nservice = ApiKeyService(\n    repo=repo,\n    hasher=hasher,\n)\n\n\nasync def main():\n    entity, api_key = await service.create(name=\"development\")\n    print(\"Give this secret to the client:\", api_key)\n\n    verified = await service.verify_key(api_key)\n    print(\"Verified key belongs to:\", verified.id_)\n\n\nasyncio.run(main())\n</code></pre>"},{"location":"quickstart/#3-persist-api-key","title":"3. Persist api key","text":"<p>Swap the repository for the SQL implementation and connect it to an async engine. This mirrors <code>examples/example_sql.py</code>.</p> <pre><code>import asyncio\nimport os\nfrom pathlib import Path\n\nfrom sqlalchemy.ext.asyncio import AsyncSession, async_sessionmaker, create_async_engine\n\nfrom fastapi_api_key import ApiKeyService\nfrom fastapi_api_key.hasher.argon2 import Argon2ApiKeyHasher\nfrom fastapi_api_key.repositories.sql import SqlAlchemyApiKeyRepository\n\n# Set env var to override default pepper\n# Using a strong, unique pepper is crucial for security\n# Default pepper is insecure and should not be used in production\npepper = os.getenv(\"SECRET_PEPPER\")\nhasher = Argon2ApiKeyHasher(pepper=pepper)\n\npath = Path(__file__).parent / \"db.sqlite3\"\ndatabase_url = os.environ.get(\"DATABASE_URL\", f\"sqlite+aiosqlite:///{path}\")\n\nasync_engine = create_async_engine(database_url, future=True)\nasync_session_maker = async_sessionmaker(\n    async_engine,\n    class_=AsyncSession,\n    expire_on_commit=False,\n)\n\n\nasync def main():\n    async with async_session_maker() as session:\n        repo = SqlAlchemyApiKeyRepository(session)\n\n        # Don't need to create Base and ApiKeyModel, the repository does it for you\n        await repo.ensure_table(async_engine=async_engine)\n\n        service = ApiKeyService(repo=repo, hasher=hasher)\n\n        # Entity have updated id after creation\n        entity, secret = await service.create(name=\"persistent\")\n        print(\"Stored key\", entity.id_, \"secret\", secret)\n\n        # Don't forget to commit the session to persist the key\n        # You can also use a transaction `async with session.begin():`\n        await session.commit()\n\n\nasyncio.run(main())\n</code></pre> <p>Next, explore the detailed usage guides which embed the full example scripts from the repository.</p>"},{"location":"usage/cache/","title":"Cache","text":"<p>When user give his api key to access your services, you often need to verify it against the stored hash. You must calculate the hash of the provided key and compare it to the stored hash. This operation can be computationally expensive, especially if you are using strong hashing algorithms like Argon2 or bcrypt. To improve performance, you can implement a caching layer that stores the results of previous hash verifications. This way, if the same API key is verified multiple times, you can retrieve the result from the cache instead of recalculating the hash each time.</p> <p>We use <code>aiocache</code> to provide caching capabilities. This library has backend-agnostic support (in-memory, Redis, etc.) and supports async operations.</p>"},{"location":"usage/cache/#security-model","title":"Security Model","text":"<p>The <code>CachedApiKeyService</code> uses a secure caching strategy that maintains the same security guarantees as the non-cached service:</p> <p>Cache key = SHA256(full_api_key)</p> <p>This ensures that:</p> <ul> <li>Only requests with the complete and correct API key can hit the cache</li> <li>An attacker who only knows the <code>key_id</code> (visible in the API key format) cannot exploit the cache</li> <li>The cached entity is only returned if the caller proves knowledge of the full secret</li> </ul> <p>A secondary index (<code>key_id \u2192 cache_key</code>) enables cache invalidation when updating or deleting API keys, even though the service doesn't store the plain secret.</p> <p></p>"},{"location":"usage/cache/#configuration","title":"Configuration","text":""},{"location":"usage/cache/#cache-backend","title":"Cache Backend","text":"<p>You can use any <code>aiocache</code> backend. Configure TTL via the service:</p> <pre><code>from aiocache import SimpleMemoryCache\nfrom aiocache import Cache\n\n# In-memory (default)\nmemory_cache = SimpleMemoryCache()\nservice = CachedApiKeyService(repo=repo, hasher=hasher, cache=memory_cache, cache_ttl=300)\n\n# Redis backend\nredis_cache = Cache(Cache.REDIS, endpoint=\"localhost\", port=6379, namespace=\"api_keys\")\nservice = CachedApiKeyService(repo=repo, hasher=hasher, cache=redis_cache, cache_ttl=600)\n</code></pre>"},{"location":"usage/cache/#example","title":"Example","text":"<p>This is the canonical example from <code>examples/example_cached.py</code>:</p> <p>Always set a pepper</p> <p>The default pepper is a placeholder. Set <code>SECRET_PEPPER</code> (or pass it explicitly to the hashers) in every environment.</p> <pre><code>import asyncio\nimport math\nimport os\nimport time\nfrom contextlib import contextmanager\n\nfrom fastapi_api_key import ApiKeyService\nfrom fastapi_api_key.hasher.argon2 import Argon2ApiKeyHasher\nfrom fastapi_api_key.repositories.in_memory import InMemoryApiKeyRepository\nfrom fastapi_api_key.services.cached import CachedApiKeyService\n\n# Set env var to override default pepper\n# Using a strong, unique pepper is crucial for security\n# Default pepper is insecure and should not be used in production\npepper = os.getenv(\"SECRET_PEPPER\")\nhasher = Argon2ApiKeyHasher(pepper=pepper)\n\n# default hasher is Argon2 with a default pepper (to be changed in prod)\nrepo = InMemoryApiKeyRepository()\n\n\n@contextmanager\ndef benchmark(n: int):\n    time_start = time.perf_counter()\n    yield\n    time_end = time.perf_counter()\n    time_elapsed = time_end - time_start\n\n    ops_per_sec = math.trunc(n / time_elapsed)\n    print(f\"  Elapsed time: {time_elapsed:.6f} seconds ({ops_per_sec:,} ops/sec)\\n\")\n\n\nasync def main():\n    n = 100\n\n    for service in [\n        # Must use Argon2 hash each call\n        ApiKeyService(repo=repo, hasher=hasher),\n        # Use Argon2 once and cache the result\n        CachedApiKeyService(repo=repo, hasher=hasher),\n    ]:\n        print(f\"{service.__class__.__name__}\")\n        print(\"- First operation (uncached):\")\n\n        _, api_key = await service.create(name=\"dev\")\n\n        with benchmark(1):\n            await service.verify_key(api_key)\n\n        print(f\"- Subsequent {n} operations (cached where applicable):\")\n\n        with benchmark(n):\n            for _ in range(n):\n                await service.verify_key(api_key)\n\n\nif __name__ == \"__main__\":\n    asyncio.run(main())\n</code></pre>"},{"location":"usage/cache/#cache-invalidation","title":"Cache Invalidation","text":"<p>The cache is automatically invalidated when:</p> <ul> <li>An API key is updated (e.g., scopes changed, deactivated)</li> <li>An API key is deleted</li> </ul> <p>This ensures that changes to API keys take effect immediately, even for cached entries.</p>"},{"location":"usage/database/","title":"Database Configuration","text":"<p>This guide covers SQLAlchemy setup with aiosqlite for persistent API key storage.</p>"},{"location":"usage/database/#installation","title":"Installation","text":"<p>Install the SQLAlchemy extra:</p> <pre><code>pip install fastapi-api-key[sqlalchemy]\n</code></pre>"},{"location":"usage/database/#example","title":"Example","text":"<p>This is the canonical example from <code>examples/example_sql.py</code>:</p> <p>Always set a pepper</p> <p>The default pepper is a placeholder. Set <code>SECRET_PEPPER</code> (or pass it explicitly to the hashers) in every environment.</p> <pre><code>import asyncio\nimport os\nfrom pathlib import Path\n\nfrom sqlalchemy.ext.asyncio import AsyncSession, async_sessionmaker, create_async_engine\n\nfrom fastapi_api_key import ApiKeyService\nfrom fastapi_api_key.hasher.argon2 import Argon2ApiKeyHasher\nfrom fastapi_api_key.repositories.sql import SqlAlchemyApiKeyRepository\n\n# Set env var to override default pepper\n# Using a strong, unique pepper is crucial for security\n# Default pepper is insecure and should not be used in production\npepper = os.getenv(\"SECRET_PEPPER\")\nhasher = Argon2ApiKeyHasher(pepper=pepper)\n\npath = Path(__file__).parent / \"db.sqlite3\"\ndatabase_url = os.environ.get(\"DATABASE_URL\", f\"sqlite+aiosqlite:///{path}\")\n\nasync_engine = create_async_engine(database_url, future=True)\nasync_session_maker = async_sessionmaker(\n    async_engine,\n    class_=AsyncSession,\n    expire_on_commit=False,\n)\n\n\nasync def main():\n    async with async_session_maker() as session:\n        repo = SqlAlchemyApiKeyRepository(session)\n\n        # Don't need to create Base and ApiKeyModel, the repository does it for you\n        await repo.ensure_table(async_engine=async_engine)\n\n        service = ApiKeyService(repo=repo, hasher=hasher)\n\n        # Entity have updated id after creation\n        entity, secret = await service.create(name=\"persistent\")\n        print(\"Stored key\", entity.id_, \"secret\", secret)\n\n        # Don't forget to commit the session to persist the key\n        # You can also use a transaction `async with session.begin():`\n        await session.commit()\n\n\nasyncio.run(main())\n</code></pre>"},{"location":"usage/dotenv/","title":"Dotenv","text":"<p>If you don't need to have complex system (add, remove, update API keys) management, you can use environment variables to store your API keys.</p> <p>You can generate API keys using the CLI <code>create</code> command or programmatically, then store them in your <code>.env</code> file:</p> <pre><code>API_KEY_DEV=ak-dcde9fa8eec44aa2-n8JK2HPXoosH6UXPL5h2YeO3OdW55WESb97CKc7mbVUzFpWFQYLuDD7Xs8fbco5d\n</code></pre>"},{"location":"usage/dotenv/#example","title":"Example","text":"<p>This is the canonical example from <code>examples/example_inmemory_env.py</code>:</p> <p>Always set a pepper</p> <p>The default pepper is a placeholder. Set <code>SECRET_PEPPER</code> (or pass it explicitly to the hashers) in every environment.</p> <pre><code>import asyncio\nimport os\n\nfrom fastapi_api_key import ApiKeyService\nfrom fastapi_api_key.hasher.argon2 import Argon2ApiKeyHasher\nfrom fastapi_api_key.repositories.in_memory import InMemoryApiKeyRepository\n\n# Set env var to override default pepper\n# Using a strong, unique pepper is crucial for security\n# Default pepper is insecure and should not be used in production\npepper = os.getenv(\"SECRET_PEPPER\")\nhasher = Argon2ApiKeyHasher(pepper=pepper)\n\n# default hasher is Argon2 with a default pepper (to be changed in prod)\nrepo = InMemoryApiKeyRepository()\nservice = ApiKeyService(\n    repo=repo,\n    hasher=hasher,\n)\n# You can use load_dotenv for loading from .env\n# from dotenv import load_dotenv\n# load_dotenv()\n\n# Ensure that you respect the format of service\nos.environ[\"API_KEY_DEV\"] = \"ak-92f5326fb9b44ab7-fSvBMig0r2vY3WR2SmGoZwM949loPU7Yy1JkjIz3RzfCEkQrprQWqQuToLbM2FzN\"\n\n\nasync def main():\n    # Load api keys from os.environ\n    await service.load_dotenv()  # envvar_prefix=\"API_KEY_\"\n\n    # Get api key for tests purposes\n    api_key = os.environ[\"API_KEY_DEV\"]\n\n    verified = await service.verify_key(api_key)\n    print(\"Verified key belongs to:\", verified.name)\n\n\nasyncio.run(main())\n</code></pre>"},{"location":"usage/fastapi/","title":"FastAPI","text":"<p>Mount CRUD endpoints that expose your key store over HTTP. The router wires the service, repository, and hashers together using FastAPI dependency injection.</p>"},{"location":"usage/fastapi/#features","title":"Features","text":"<ul> <li>One call to <code>create_api_keys_router</code> registers create/list/get/update/delete routes.</li> <li>Depends on an async session factory (see <code>async_sessionmaker</code>).</li> <li>Shares a single <code>ApiKeyHasher</code> instance across requests.</li> </ul>"},{"location":"usage/fastapi/#example","title":"Example","text":"<p>This is the canonical example from <code>examples/example_fastapi.py</code>:</p> <p>Always set a pepper</p> <p>The default pepper is a placeholder. Set <code>SECRET_PEPPER</code> (or pass it explicitly to the hashers) in every environment.</p> <pre><code>import os\nfrom pathlib import Path\nfrom typing import AsyncIterator\n\nfrom fastapi import FastAPI, Depends, APIRouter\nfrom sqlalchemy.ext.asyncio import create_async_engine, async_sessionmaker, AsyncSession\n\nfrom fastapi_api_key import ApiKey, ApiKeyService\nfrom fastapi_api_key.hasher.argon2 import Argon2ApiKeyHasher\nfrom fastapi_api_key.repositories.sql import SqlAlchemyApiKeyRepository\nfrom fastapi_api_key.api import create_api_keys_router, create_depends_api_key\n\n# Set env var to override default pepper\n# Using a strong, unique pepper is crucial for security\n# Default pepper is insecure and should not be used in production\npepper = os.getenv(\"SECRET_PEPPER\")\nhasher = Argon2ApiKeyHasher(pepper=pepper)\n\npath = Path(__file__).parent / \"db.sqlite3\"\ndatabase_url = os.environ.get(\"DATABASE_URL\", f\"sqlite+aiosqlite:///{path}\")\n\nasync_engine = create_async_engine(database_url, future=True)\nasync_session_maker = async_sessionmaker(\n    async_engine,\n    class_=AsyncSession,\n    expire_on_commit=False,\n)\n\napp = FastAPI(title=\"API with API Key Management\")\n\n\nasync def get_async_session() -&gt; AsyncIterator[AsyncSession]:\n    \"\"\"Dependency to provide an active SQLAlchemy async session.\"\"\"\n    async with async_session_maker() as session:\n        async with session.begin():\n            yield session\n\n\nasync def get_svc_api_keys(async_session: AsyncSession = Depends(get_async_session)) -&gt; ApiKeyService:\n    \"\"\"Dependency to inject the API key service with an active SQLAlchemy async session.\"\"\"\n    repo = SqlAlchemyApiKeyRepository(async_session)\n\n    # Necessary if you don't use your own DeclarativeBase\n    await repo.ensure_table(async_engine=async_engine)\n\n    return ApiKeyService(repo=repo, hasher=hasher)\n\n\nsecurity = create_depends_api_key(get_svc_api_keys)\nrouter_protected = APIRouter(prefix=\"/protected\", tags=[\"Protected\"])\n\nrouter = APIRouter(prefix=\"/api-keys\", tags=[\"API Keys\"])\nrouter_api_keys = create_api_keys_router(\n    get_svc_api_keys,\n    router=router,\n)\n\n\n@router_protected.get(\"/\")\nasync def read_protected_data(api_key: ApiKey = Depends(security)):\n    return {\n        \"message\": \"This is protected data\",\n        \"apiKey\": {\n            \"id\": api_key.id_,\n            \"name\": api_key.name,\n            \"description\": api_key.description,\n            \"isActive\": api_key.is_active,\n            \"createdAt\": api_key.created_at,\n            \"expiresAt\": api_key.expires_at,\n            \"lastUsedAt\": api_key.last_used_at,\n        },\n    }\n\n\napp.include_router(router_api_keys)\napp.include_router(router_protected)\n\nif __name__ == \"__main__\":\n    import uvicorn\n\n    uvicorn.run(app, host=\"localhost\", port=8000)\n</code></pre> <p>I recommend you to create your own <code>Base</code> and models instead of reusing the example code. <pre><code>import os\nfrom contextlib import asynccontextmanager\nfrom pathlib import Path\nfrom typing import AsyncIterator\n\nfrom fastapi import FastAPI, Depends, APIRouter\nfrom sqlalchemy.ext.asyncio import create_async_engine, async_sessionmaker, AsyncSession\nfrom sqlalchemy.orm import DeclarativeBase\n\nfrom fastapi_api_key import ApiKey, ApiKeyService\nfrom fastapi_api_key.api import create_api_keys_router, create_depends_api_key\nfrom fastapi_api_key.hasher.argon2 import Argon2ApiKeyHasher\nfrom fastapi_api_key.repositories.sql import SqlAlchemyApiKeyRepository, ApiKeyModelMixin\n\n\nclass Base(DeclarativeBase): ...\n\n\nclass ApiKeyModel(Base, ApiKeyModelMixin): ...\n\n\n@asynccontextmanager\nasync def lifespan(_: FastAPI) -&gt; AsyncIterator[None]:\n    # Create the database tables\n    async with async_engine.begin() as conn:\n        await conn.run_sync(Base.metadata.create_all)\n    yield\n\n\n# Set env var to override default pepper\n# Using a strong, unique pepper is crucial for security\n# Default pepper is insecure and should not be used in production\npepper = os.getenv(\"SECRET_PEPPER\")\nhasher = Argon2ApiKeyHasher(pepper=pepper)\n\npath = Path(__file__).parent / \"db.sqlite3\"\ndatabase_url = os.environ.get(\"DATABASE_URL\", f\"sqlite+aiosqlite:///{path}\")\n\nasync_engine = create_async_engine(database_url, future=True)\nasync_session_maker = async_sessionmaker(\n    async_engine,\n    class_=AsyncSession,\n    expire_on_commit=False,\n)\n\napp = FastAPI(title=\"API with API Key Management\", lifespan=lifespan)\n\n\nasync def get_async_session() -&gt; AsyncIterator[AsyncSession]:\n    \"\"\"Dependency to provide an active SQLAlchemy async session.\"\"\"\n    async with async_session_maker() as session:\n        async with session.begin():\n            yield session\n\n\nasync def get_svc_api_keys(async_session: AsyncSession = Depends(get_async_session)) -&gt; ApiKeyService:\n    \"\"\"Dependency to inject the API key service with an active SQLAlchemy async session.\"\"\"\n    # No need to ensure table here, done in lifespan\n    repo = SqlAlchemyApiKeyRepository(async_session)\n    return ApiKeyService(repo=repo, hasher=hasher)\n\n\nsecurity = create_depends_api_key(get_svc_api_keys)\nrouter_protected = APIRouter(prefix=\"/protected\", tags=[\"Protected\"])\n\nrouter = APIRouter(prefix=\"/api-keys\", tags=[\"API Keys\"])\nrouter_api_keys = create_api_keys_router(\n    get_svc_api_keys,\n    router=router,\n)\n\n\n@router_protected.get(\"/\")\nasync def read_protected_data(api_key: ApiKey = Depends(security)):\n    return {\n        \"message\": \"This is protected data\",\n        \"apiKey\": api_key,\n    }\n\n\napp.include_router(router_api_keys)\napp.include_router(router_protected)\n\nif __name__ == \"__main__\":\n    import uvicorn\n\n    uvicorn.run(app, host=\"localhost\", port=8000)\n</code></pre></p>"},{"location":"usage/fastapi/#endpoints-exposed","title":"Endpoints exposed","text":"Method Path Description POST /api-keys Create a key and return the plaintext secret once. GET /api-keys List keys with offset/limit pagination. GET /api-keys/{id} Retrieve a key by identifier. PATCH /api-keys/{id} Update name, description, or activation flag. DELETE /api-keys/{id} Remove a key."},{"location":"usage/scopes/","title":"Scopes","text":"<p>This libray integrates the concept of scopes to provide fine-grained access control for API keys. Scopes are strings that define the permissions associated with an API key. When creating or updating an API key, you can specify the scopes that the key should have. If you define 2 scopes \"read\" and \"write\" to an route, an API key must have both scopes to access that route.</p>"},{"location":"usage/scopes/#example","title":"Example","text":""},{"location":"usage/scopes/#simple","title":"Simple","text":"<p>This is the canonical example from <code>examples/example_scopes.py</code>:</p> <p>Always set a pepper</p> <p>The default pepper is a placeholder. Set <code>SECRET_PEPPER</code> (or pass it explicitly to the hashers) in every environment.</p> <pre><code>import os\nfrom pathlib import Path\n\nfrom sqlalchemy.ext.asyncio import create_async_engine, async_sessionmaker, AsyncSession\n\nfrom fastapi_api_key import ApiKeyService\nfrom fastapi_api_key.domain.errors import InvalidScopes\nfrom fastapi_api_key.hasher.argon2 import Argon2ApiKeyHasher\nfrom fastapi_api_key.repositories.sql import SqlAlchemyApiKeyRepository\n\n# Set env var to override default pepper\n# Using a strong, unique pepper is crucial for security\n# Default pepper is insecure and should not be used in production\npepper = os.getenv(\"SECRET_PEPPER\")\nhasher = Argon2ApiKeyHasher(pepper=pepper)\n\npath = Path(__file__).parent / \"db.sqlite3\"\ndatabase_url = os.environ.get(\"DATABASE_URL\", f\"sqlite+aiosqlite:///{path}\")\n\nasync_engine = create_async_engine(database_url, future=True)\nasync_session_maker = async_sessionmaker(\n    async_engine,\n    class_=AsyncSession,\n    expire_on_commit=False,\n)\n\n\nasync def main():\n    async with async_session_maker() as async_session:\n        repo = SqlAlchemyApiKeyRepository(async_session)\n\n        # Necessary if you don't use your own DeclarativeBase\n        await repo.ensure_table(async_engine=async_engine)\n\n        svc = ApiKeyService(repo=repo, hasher=hasher)\n\n        # Create an API key without the required \"write\" scope\n        _, bad_api_key = await svc.create(name=\"no-scope-key\", scopes=[\"read\"])\n        _, good_api_key = await svc.create(name=\"with-scope-key\", scopes=[\"write\"])\n\n        print(f\"Bad API Key (no required scopes): '{bad_api_key}'\")\n        print(f\"Good API Key (with required scopes): '{good_api_key}'\")\n\n        await svc.verify_key(good_api_key, required_scopes=[\"write\"])\n        print(\"Successfully verified good API key with required scopes.\")\n\n        try:\n            await svc.verify_key(bad_api_key, required_scopes=[\"write\"])\n        except InvalidScopes as e:\n            print(f\"Failed to verify bad API key with required scopes: {e}\")\n\n\nif __name__ == \"__main__\":\n    import asyncio\n\n    asyncio.run(main())\n</code></pre>"},{"location":"usage/scopes/#fastapi","title":"FastAPI","text":"<p>You can create security Depends with required scopes like this:</p> <pre><code>import os\nfrom pathlib import Path\nfrom typing import AsyncIterator\n\nfrom fastapi import FastAPI, Depends, APIRouter\nfrom sqlalchemy.ext.asyncio import create_async_engine, async_sessionmaker, AsyncSession\n\nfrom fastapi_api_key import ApiKeyService\nfrom fastapi_api_key.domain.entities import ApiKey\nfrom fastapi_api_key.hasher.argon2 import Argon2ApiKeyHasher\nfrom fastapi_api_key.repositories.sql import SqlAlchemyApiKeyRepository\nfrom fastapi_api_key.api import create_api_keys_router, create_depends_api_key\n\n# Set env var to override default pepper\n# Using a strong, unique pepper is crucial for security\n# Default pepper is insecure and should not be used in production\npepper = os.getenv(\"SECRET_PEPPER\")\nhasher = Argon2ApiKeyHasher(pepper=pepper)\n\npath = Path(__file__).parent / \"db.sqlite3\"\ndatabase_url = os.environ.get(\"DATABASE_URL\", f\"sqlite+aiosqlite:///{path}\")\n\nasync_engine = create_async_engine(database_url, future=True)\nasync_session_maker = async_sessionmaker(\n    async_engine,\n    class_=AsyncSession,\n    expire_on_commit=False,\n)\n\napp = FastAPI(title=\"API with API Key Management\")\n\n\nasync def get_async_session() -&gt; AsyncIterator[AsyncSession]:\n    \"\"\"Dependency to provide an active SQLAlchemy async session.\"\"\"\n    async with async_session_maker() as session:\n        async with session.begin():\n            yield session\n\n\nasync def get_svc_api_keys(async_session: AsyncSession = Depends(get_async_session)) -&gt; ApiKeyService:\n    \"\"\"Dependency to inject the API key service with an active SQLAlchemy async session.\"\"\"\n    repo = SqlAlchemyApiKeyRepository(async_session)\n    # Necessary if you don't use your own DeclarativeBase\n    await repo.ensure_table(async_engine=async_engine)\n    return ApiKeyService(repo=repo, hasher=hasher)\n\n\n# Create security dependency that requires \"write\" scope\nsecurity = create_depends_api_key(get_svc_api_keys, required_scopes=[\"write\"])\nrouter_protected = APIRouter(prefix=\"/protected\", tags=[\"Protected\"])\n\nrouter = APIRouter(prefix=\"/api-keys\", tags=[\"API Keys\"])\nrouter_api_keys = create_api_keys_router(\n    get_svc_api_keys,\n    router=router,\n)\n\n\n@router_protected.get(\"/\")\nasync def read_protected_data(api_key: ApiKey = Depends(security)):\n    return {\n        \"message\": \"This is protected data\",\n        \"apiKey\": {\n            \"id\": api_key.id_,\n            \"name\": api_key.name,\n            \"description\": api_key.description,\n            \"isActive\": api_key.is_active,\n            \"createdAt\": api_key.created_at,\n            \"expiresAt\": api_key.expires_at,\n            \"lastUsedAt\": api_key.last_used_at,\n        },\n    }\n\n\napp.include_router(router_api_keys)\napp.include_router(router_protected)\n\n\nasync def main():\n    async with async_session_maker() as async_session:\n        repo = SqlAlchemyApiKeyRepository(async_session)\n\n        # Necessary if you don't use your own DeclarativeBase\n        await repo.ensure_table(async_engine=async_engine)\n\n        svc = ApiKeyService(repo=repo, hasher=hasher)\n\n        # Create an API key without the required \"write\" scope\n        _, bad_api_key = await svc.create(name=\"no-scope-key\", scopes=[\"read\"])\n        _, good_api_key = await svc.create(name=\"with-scope-key\", scopes=[\"write\"])\n\n        print(f\"Bad API Key (no required scopes): '{bad_api_key}'\")\n        print(f\"Good API Key (with required scopes): '{good_api_key}'\")\n\n        await async_session.commit()\n\n\nif __name__ == \"__main__\":\n    import asyncio\n\n    # Create an invalid and a valid API key for testing\n    asyncio.run(main())\n\n    import uvicorn\n\n    # Run the FastAPI app and test the 2 api keys against the protected endpoint\n    uvicorn.run(app, host=\"localhost\", port=8000)\n</code></pre>"},{"location":"usage/typer/","title":"Typer","text":"<p>Mount CLI commands that expose your key store over the command line. The CLI wires the service, repository, and hashers together using Typer dependency injection.</p>"},{"location":"usage/typer/#features","title":"Features","text":"<ul> <li>One call to <code>create_api_keys_cli</code> registers create, list, get, update, delete and verify commands.</li> <li>Depends on an async session factory (see <code>async_sessionmaker</code>).</li> <li>Shares a single <code>ApiKeyHasher</code> instance across requests.</li> </ul>"},{"location":"usage/typer/#example","title":"Example","text":"<p>This is the canonical example from <code>examples/example_cli.py</code>.</p> <p>Always set a pepper</p> <p>The default pepper is a placeholder. Set <code>SECRET_PEPPER</code> (or pass it explicitly to the hashers) in every environment.</p> <pre><code>import os\nfrom contextlib import asynccontextmanager\nfrom pathlib import Path\nfrom typing import AsyncIterator\n\nfrom sqlalchemy.ext.asyncio import AsyncSession, async_sessionmaker, create_async_engine\nfrom sqlalchemy.orm import DeclarativeBase\n\nfrom fastapi_api_key import ApiKeyService\nfrom fastapi_api_key.cli import create_api_keys_cli\nfrom fastapi_api_key.hasher.argon2 import Argon2ApiKeyHasher\nfrom fastapi_api_key.repositories.sql import SqlAlchemyApiKeyRepository, ApiKeyModelMixin\n\n\nclass Base(DeclarativeBase): ...\n\n\nclass ApiKeyModel(Base, ApiKeyModelMixin): ...\n\n\n# Set env var to override default pepper\n# Using a strong, unique pepper is crucial for security\n# Default pepper is insecure and should not be used in production\npepper = os.getenv(\"SECRET_PEPPER\")\nhasher = Argon2ApiKeyHasher(pepper=pepper)\n\npath = Path(__file__).parent / \"db.sqlite3\"\ndatabase_url = os.environ.get(\"DATABASE_URL\", f\"sqlite+aiosqlite:///{path}\")\n\nasync_engine = create_async_engine(database_url, future=True)\nasync_session_maker = async_sessionmaker(\n    async_engine,\n    class_=AsyncSession,\n    expire_on_commit=False,\n)\n\n\n@asynccontextmanager\nasync def service_factory() -&gt; AsyncIterator[ApiKeyService]:\n    \"\"\"Yield an ApiKeyService backed by the SQLite SQLAlchemy repository.\"\"\"\n    async with async_engine.begin() as conn:\n        await conn.run_sync(Base.metadata.create_all)\n\n    async with async_session_maker() as async_session:\n        repo = SqlAlchemyApiKeyRepository(async_session=async_session)\n        service = ApiKeyService(repo=repo, hasher=hasher)\n        try:\n            yield service\n            await async_session.commit()\n        except Exception:\n            await async_session.rollback()\n            raise\n\n    await async_engine.dispose()\n\n\napp = create_api_keys_cli(service_factory)\n\nif __name__ == \"__main__\":\n    # Run the CLI with `uv run examples/example_cli.py`\n    app()\n</code></pre>"},{"location":"usage/typer/#commands-exposed","title":"Commands exposed","text":"Command Description <code>create</code> Create a new API key <code>list</code> List all API keys <code>get &lt;id&gt;</code> Get details of a specific API key <code>delete &lt;id&gt;</code> Delete an API key <code>verify &lt;api_key&gt;</code> Verify an API key <code>update &lt;id&gt;</code> Update an existing API key <code>activate &lt;id&gt;</code> Activate an API key <code>deactivate &lt;id&gt;</code> Deactivate an API key <code>search</code> Search API keys with filters <code>count</code> Count API keys"}]}